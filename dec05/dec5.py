# -*- coding: utf-8 -*-
"""Dec5_newtable

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Yj6q2rgSLuD0EAi_F0hpCx5jpsGmEmKo
"""

import numpy as np

with open('Dec5.txt','r') as f:
  lines = f.readlines()

def read_seeds(line):
  split0 = line.split(':')
  seednums = split0[1].split()
  seeds = [int(seed) for seed in seednums]
  return seeds

def fill_in_table(map):
  if map[0,1] > 0:
    map = np.insert(map,0,[0, 0, map[0,1]],axis=0)

  row = 0
  while row < (map.shape[0]-1):
    if map[row,1]+ map[row,2] < map[row+1,1]:
      start = map[row,1]+ map[row,2]
      rlen = map[row+1,1] - start
      map = np.insert(map,row+1,[start, start, rlen],axis=0)
    row += 1
  # Last row: Append a row at end with rlen=-1
  row = map.shape[0]-1
  if (map[row,2]) != -1:
    start = map[row,1]+map[row,2]
    rlen = -1
    map = np.append(map,[[start, start, rlen]],axis=0)

  return map

def read_table(lines):
  # Read lines until an empty line is found
  values = []
  num_lines = 0
  for line in lines:
    if not line.strip(): break

    linevalues = [int(val) for val in line.split()]
    values.append(linevalues)
    num_lines += 1

  mapping_table = np.array(values)
  # The second entry is the source range so sort by the source range
  mapping_table = mapping_table[mapping_table[:,1].argsort()]
  mapping_table = fill_in_table(mapping_table)
  return [num_lines, mapping_table]

# Now read in all the information from the file
seeds = read_seeds(lines[0])

maps = []
linecnt=3
for cnt in range(7):
  [size,new_map] = read_table(lines[linecnt:])
  linecnt += size+2
  maps.append(new_map)

maps[0]

def map_value(map,val):
  # For an input value for the output using the map provided
  # Find the table entry corresponduing to the input value

  # In this version the tables have no gaps.
  # Thus don't need to check if below first entry or for gaps
  row  = np.max(np.nonzero(map[:,1]<=val))

  rowstart = map[row,1]
  offset = val - rowstart

  return map[row,0]+offset

out = map_value(maps[0],4294967296+1000)
out

maps[0] # seed_soil_map

# Now perform the mapping through all the maps
def find_location_from_seed(seed):
  temp_val = seed
  for cnt in range(7):
    temp_val = map_value(maps[cnt],temp_val)

  return temp_val

find_location_from_seed(seeds[0])

# Part 1 Find the nearest location
locations = np.zeros([len(seeds)],dtype=int)

for cnt in range(len(seeds)):
  locations[cnt] = find_location_from_seed(seeds[cnt])

print(f'Part 1 Nearest Location: {np.min(locations)}')

locations

def map_value_endvalrow(map,val):
  # Return the mapped value for an input val for map map
  # But also return the index for the next row so ranges can be calculated
  # Note a endr=-1 indicates the last of a table and no limit to range
  row  = np.max(np.nonzero(map[:,1]<=val))

  rowstart = map[row,1]
  offset = val - rowstart
  endvalrow = -1 if map[row,2]<0 else (map[row,1]+map[row,2])

  return [map[row,0]+offset, endvalrow]

# Map a range of values from one map to the next and return a list of ranges
# and lengths to the next map
def map_range(map,val,rlen):
  #print('Here')
  ranges = []
  while (rlen>0):
    [newval,endvalrow] = map_value_endvalrow(map, val)
    numvals = rlen if ((endvalrow<0) or (val+rlen < endvalrow)) else (endvalrow-val)
    ranges.append([newval,numvals])
    val = endvalrow
    rlen = rlen - numvals

  return (ranges)

def map_seed_to_location_ranges(seed,rlen):

  ranges = map_range(maps[0],seed,rlen)

  for cnt in range(1,7):
    ranges_out = []
    for temp_range in ranges:
      new_ranges = map_range(maps[cnt],temp_range[0],temp_range[1])
      for r in new_ranges:
        ranges_out.append(r)
    ranges = ranges_out

  return ranges

ranges = map_range(maps[0],seeds[0],seeds[1])
ranges

ranges = map_range(maps[0],seeds[0],seeds[1])
ranges

cnt=6
ranges_out=[]
for temp_range in ranges:
  new_ranges = map_range(maps[cnt],temp_range[0],temp_range[1])
  for r in new_ranges:
     ranges_out.append(r)
ranges = ranges_out
ranges

np.sum(np.array(ranges),axis=0)

seeds[0:2]

cnt = 2
rout = map_seed_to_location_ranges(seeds[cnt], seeds[cnt+1])
seeds[2:4]
rout

# Find the minimum location by propagating the ranges
min_loc =find_location_from_seed(seeds[0])
r = []
for cnt in range(0,len(seeds),2):
  rout = map_seed_to_location_ranges(seeds[cnt], seeds[cnt+1])
  #print(len(rout))
  new_min = np.min(np.array(rout)[:,0])
  if new_min<min_loc: min_loc=new_min
  [r.append(newr) for newr in rout]
  #print(rout)

print(f'Part2: Min Locaion {min_loc}')