# -*- coding: utf-8 -*-
"""Dec10.inpyb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1r7H5PyXQZxXXoC_lrnRiionFJyuKazsB

## Dec 10 2023: Traverse a labyrinth
"""

import numpy as np
import pandas as pd

def search_node(map,location):
  row = location[0]
  col = location[1]
  if map[row-1,col] in '|7F':      # Up
    return([row-1,col])
  elif map[row+1,col] in '|LJ':     # Down
    return([row+1,col])
  elif map[row,col+1] in '-J7':      # Right
    return [row,col+1]
  elif map[row,col-1] in '-FL':     # Left
    return [row,col-1]

def follow_node(map,curpoint,lastpoint,path):
  row = curpoint[0]
  col = curpoint[1]
  path.append([row,col])
  match map[row,col]:
    case '|':
      nextsquare = [row+1,col] if not [row+1,col]==lastpoint else [row-1,col]
    case '7':
      nextsquare = [row+1,col] if not [row+1,col]==lastpoint else [row,col-1]
    case 'F':
      nextsquare = [row+1,col] if not [row+1,col]==lastpoint else [row,col+1]
    case 'L':
      nextsquare = [row-1,col] if not [row-1,col]==lastpoint else [row,col+1]
    case 'J':
      nextsquare = [row-1,col] if not [row-1,col]==lastpoint else [row,col-1]
    case '-':
      nextsquare = [row,col+1] if not [row,col+1]==lastpoint else [row,col-1]
    case 'S':
      print('Back at starting point')
      nextsquare = []

  #follow_node(map,nextsquare,curpoint,path)
  return nextsquare

#with open('Dec10testB.txt','r') as f:
with open('Dec10.txt','r') as f:
  lines = f.readlines()

#Import the map
map = []
for line in lines:
  map.append(list(line.strip()))
map = np.array(map)

# Find the starting line
for lcnt in range(len(lines)):
  if not 'S' in lines[lcnt]: continue
  rowStart = lcnt
  break
for rcnt in range(len(lines[rowStart])):
  if lines[rowStart][rcnt]=='S':
    colStart = rcnt
    break

# Search all around the map for the two connecting values
path=[[rowStart,colStart]]
firstsquare = path[0]
nextsquare = search_node(map,path[0])
while(1):
  next = follow_node(map,nextsquare,firstsquare,path)
  if next:
    firstsquare = nextsquare
    nextsquare = next
  else:
    break

(len(path)-1)//2

def make_str(arr):
  out = ''
  for a in arr: out+= a
  return out

def plot_map(map):
  mapOut =[]
  for row in range(map.shape[0]):
    mapOut.append(make_str(map[row,:]))
  return(mapOut)

"""## Part 2

def is_interior(map,pos):
  is_inside = []

  # Test only points not on edge
  if not (pos[1]>0 and pos[1]<=map.shape[1]-2 and \
    pos[0]>0 and pos[0]<=map.shape[0]-2):
    is_inside.append(0)
  else:
    for direction in ['N', 'S', 'E', 'W']:
      match direction:
        case 'E':
          test_vector = map[pos[0],:pos[1]]
          numBlockages = np.sum(test_vector=='|')
        case 'W':
          test_vector = map[pos[0],(pos[1]+1):]
          numBlockages = np.sum(test_vector=='|')
        case 'N':
          test_vector = map[:pos[0],pos[1]]
          numBlockages = np.sum(test_vector=='-')
        case 'S':
          test_vector = map[(pos[0]+1):,pos[1]]
          numBlockages = np.sum(test_vector=='-')

      turnStr0 = ''.join(list(test_vector)).replace('-','').replace('|','').replace('.','')
      turnStr = [turnStr0[i:i + 2] for i in range(0, len(out), 2)]

      if direction == 'E' or direction=='W':
        numSame = np.sum(np.isin(turnStr,['FJ', 'L7']))
        numRev = np.sum(np.isin(turnStr,['F7', 'LJ']))
        if numSame+numRev != len(turnStr):
          #print(f'numSame {numSame} numRev {numRev} {numSame+numRev} != {len(turnStr)}')
          print(turnStr)
      else:
        numSame = np.sum(np.isin(turnStr,['7L', 'FJ']))
        numRev = np.sum(np.isin(turnStr,['FL', '7J']))
        if numSame+numRev != len(turnStr):
          print(f'pos {pos[0]}, {pos[1]} dir: {direction}')
          print(turnStr0)
          err

      #numGround = np.sum(test_vector=='.')
      numTurns = np.sum(np.isin(test_vector,['7','J','F','L']))

      #print(f'NumTurns {numTurns} numBlockages {numBlockages}')
      if numTurns ==2 and numBlockages ==0:
        is_inside.append(-1)        # Unsure could be either Count on another to give correct answer
      else:
        temp_inside = (numTurns/2 + numBlockages)%2
        is_inside.append(temp_inside)

    if np.sum(is_inside)==2:
      print(f'is_inside {is_inside} Position: {pos}')

  return (not np.any(is_inside==False))
"""

def determine_start_shape(map,location):
  row = location[0]
  col = location[1]
  shapekey = ''
  if map[row-1,col] in '|7F':      # Up
    shapekey += 'U'
  if map[row+1,col] in '|LJ':     # Down
    shapekey+='D'
  if map[row,col+1] in '-J7':      # Right
    shapekey +='R'
  if map[row,col-1] in '-FL':     # Left
    shapekey +='L'

  match shapekey:
    case 'UD':
      shape = '|'
    case 'UR':
      shape = 'L'
    case 'UL':
      shape = 'J'
    case 'DR':
      shape = 'F'
    case 'DL':
      shape = '7'
    case 'RL':
      shape = '-'

  return shape

def find_path(map,path):
  # Search all around the map for the two connecting values
  prev = path[0]
  ugh = type(path)
  #print(f'{path}')

  cur = search_node(map,path[0])
  while(1):
    next = follow_node(map,cur,prev,path)
    if not np.all(next==path[0]):
      prev = cur
      cur = next
    else:
      break

# Determine if the path encircles a given point
def is_encircled(pathMap,pos):
  row = pos[0]
  col = pos[1]
  left = np.any(pathMap[row,:col]=='P')
  right = np.any(pathMap[row,col:]=='P')
  up = np.any(pathMap[:row,col]=='P')
  down = np.any(pathMap[row:,col]=='P')
  return (up and down and right and left)

# mark_adjacent as outside
def mark_adjacent_as_outside(map,pathMap,pos):
  row = pos[0]
  col = pos[1]

  print(f'(r,c)= {row}, {col}')
  #if not map[row,col]=='.':
  map[row,col] ='O' if map[row,col]=='.' else 'G'

  for r in range(-1,2):
    if (row+r<0) or (row+r >= map.shape[0]): continue
    for c in range(-1,2):
      if (col+c<0) or (col+c >=map.shape[1]) or(r==0 and c==0) : continue

      if pathMap[row+r,col+c]=='P' or map[row+r,col+c]=='O' or map[row+r,col+c] =='G':
        continue
      elif np.isin(map[row+r,col+c], ['.','|','-', 'L','J','F','7']):   # '.' or 'LF-|J7' :
        mark_adjacent_as_outside(map,pathMap,[row+r,col+c])
      else:
        print(f'Invalid point {point}')

def extract_str(array):
  mystr = ''.join(list(array))

# Test for interior points using number crossing
# Takes into account lines on the row being tested
# Be sure to use a clean map (remove turns, | and - not on main path)
def check_enclosed(map,pathMap,pos):

  # Test only points not on edge
  # Assume
  if not (pos[1]>0 and pos[1]<=map.shape[1]-2 and \
    pos[0]>0 and pos[0]<=map.shape[0]-2):
    return (0)

  # Extract array each direction
  left = ''.join(map[row,col::-1])
  right = ''.join(map[row,col:])
  up = ''.join(map[row::-1,col])
  down = ''.join(map[row:,col])

# Shorten arrays to stop at first 'O' or 'G'
  index = min_gtz([left.find('G'), left.find('O')])
  left = left[:index+1]
  index = min_gtz([right.find('G'), right.find('O')])
  right = right[:index+1]
  index = min_gtz([up.find('G'), up.find('O')])
  up = up[:index+1]
  index = min_gtz([down.find('G'), down.find('O')])
  down = down[:index+1]

  numBlockages = np.array([0,0,0,0])
  numBlockages[0] = left.count('|')
  numBlockages[1] = right.count('|')
  numBlockages[2] = up.count('-')
  numBlockages[3] = down.count('-')

  print(f'NB {numBlockages}')
  if np.any(numBlockages == 0):
    print('here')
    mark_adjacent_as_outside(map,pathMap,[row,col])
  return

def show_path_with_turns(map,path):
  for cnt in range(len(path)):
    if np.isin(map[ path[cnt][0], path[cnt][1]],['7','J','F','L']): map[ path[cnt][0], path[cnt][1]]='T'
  return map

def show_path(map,path):
  for cnt in range(len(path)):
    map[ path[cnt][0], path[cnt][1]]='P'
  return map

#  Last part 2
# Find path - draw path on copy of map
# count number of crossing a vector from each ground pixel has to an edge
# Even # or zero - outside
# Odd # - inside

# 1: Read in original map
# Load small test file
#with open('Dec10test.txt','r') as f:
#with open('Dec10testB.txt','r') as f:
with open('Dec10.txt','r') as f:
  lines = f.readlines()

# Import the map
map = []
for line in lines:
  map.append(list(line.strip()))
map = np.array(map)

# Find the starting point
[r,c] = np.where(map=='S')
start = [r[0],c[0]]
path=[start]
map[r[0],[c[0]]] = determine_start_shape(map,start)
# Find the closed path
path=[start]
find_path(map,path)

# Replace the path with letter 'P'
pathMap = np.copy(map)
pathMap = show_path(pathMap,path)

cleanMap = np.copy(map)
cleanMap[pathMap!='P'] = '.'

# Check each point if it is encircled
[Grows,Gcols] = np.where(map=='.')
for row in range(map.shape[0]):
  for col in range(map.shape[1]):
    if not is_encircled(pathMap,[row,col]):
      map[row,col] = 'O'  if (map[row,col]=='.') else 'G'
    #print(f'Not encircled row {row}, col: {col}')
    # mark_adjacent_as_outside(map,pathMap,[row,col])

# Check each point if it is interior
[Grows,Gcols] = np.where(map=='.')
for cnt in range(len(Grows)):
  row = Grows[cnt]
  col = Gcols[cnt]
  if map[row,col]=='.':
    print(f'row {row}, col: {col}')
    check_enclosed(map,pathMap,[row,col])
plot_map(map)
np.sum(map=='.')

plot_map(pathMap)

np.sum(map=='.')

left

np.sum(map=='.')

['..........',
 '.F------7.',
 '.|......|.',
 '.SF--7..|.',
 '.||..L--J.',
 '.|L-----7.',
 '.|......|.',
 '.|.F-7..|.',
 '.|.|.|..|.',
 '.|.|FJ..|.',
 '.L-JL---J.',
 '.F--7....|',
 '.|..|..|-J',
 '.L--JF-|J7']

def min_gtz(x):
  return min([i for i in x if i>0])

min_gtz([5,10])

row = 100
col = 55
left = ''.join(map[row,col::-1])
right = ''.join(map[row,col:])
up = ''.join(map[row::-1,col])
down = ''.join(map[row:,col])

# Shorten arrays to stop at first 'O' or 'G'
index = min_gtz([left.find('G'), left.find('O')])
left = left[:index+1]
index = min_gtz([right.find('G'), right.find('O')])
right = right[:index+1]
index = min_gtz([up.find('G'), up.find('O')])
up = up[:index+1]
index = min_gtz([down.find('G'), down.find('O')])
down = down[:index+1]

numBlockages = np.array([0,0,0,0])
numBlockages[0] = left.count('|')
numBlockages[1] = right.count('|')
numBlockages[2] = up.count('-')
numBlockages[3] = down.count('-')

numBlockages

up

"".join(map[101:90:-1,55])

map[100,55]

col

left

left.find('7')

row = 100
col = 54
left = np.any(pathMap[row,:col]=='P')
right = np.any(pathMap[row,col:]=='P')
up = np.any(pathMap[:row,col]=='P')
down = np.any(pathMap[row:,col]=='P')
[left,right,up,down]

map[row,:col]=='P'

with open('Dec10.txt','r') as f:
  lines = f.readlines()

# Import the map
map = []
for line in lines:
  map.append(list(line.strip()))
map = np.array(map)

np.sum(map=='.')

pathMap[row,col:]=='P'

pathMap[:row,col]=='P'

pathMap[row:,col]=='P'

