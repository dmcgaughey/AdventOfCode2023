# -*- coding: utf-8 -*-
"""Dec13.inpyb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oOlhVSXqi5GJJcaezHj56QRPEJrzNS9n

## Dec 13 2023:
"""

import numpy as np
import pandas as pd
import itertools

def find_adjacent_horiz(table):
  #print(table)
  horiz_mirrors = []
  for cnt in range(table.shape[0]-1):
      if (np.all(np.char.equal(table[cnt,:], table[cnt+1,:]))):
        horiz_mirrors.append(cnt)
  else:
    #print(horiz_mirrors)
    return(horiz_mirrors)

def find_adjacent_vert(table):
  vert_mirrors = []
  for cnt in range(table.shape[1]-1):
    if (np.all(np.char.equal(table[:,cnt], table[:,cnt+1]))):
      vert_mirrors.append(cnt)
  else:
    return(vert_mirrors)

def verify_horiz_symmetry(table,horiz):
  if horiz<0: return False

  max_offset = min(horiz, table.shape[0] - horiz- 2)
  for offset in range(1, max_offset+1):
    #print(f'horiz {horiz} offset:{offset}')
    if not (np.all(np.char.equal(table[horiz-offset,:], table[horiz+offset+1,:]))):
      return False
  else:
    return True

def verify_vert_symmetry(table,vert):
  if vert<0: return False
  max_offset = min(vert, table.shape[1] - vert- 2)
  for offset in range(1,max_offset+1):
    #print(f'vert{vert} offset:{offset}')
    if not (np.all(np.char.equal(table[:,vert-offset], table[:,vert+offset+1]))):
      return False
  else:
    return True

def find_and_verify_horiz(table):
  horiz_list = find_adjacent_horiz(table)
  horiz_out = []
  if horiz_list:
    for horiz in horiz_list:
      if (verify_horiz_symmetry(table,horiz)):
         horiz_out.append(horiz)
  if not horiz_out:
    horiz_out.append(-1)
  return np.array(horiz_out)

def find_and_verify_vert(table):
  vert_list = find_adjacent_vert(table)
  vert_out = []
  if vert_list:
    for vert in vert_list:
      if (verify_vert_symmetry(table,vert)):
        vert_out.append(vert)
  if not vert_out:
    vert_out.append(-1)
  return np.array(vert_out)

def test_change_one(table,oldCount):
  score_changes = []
  for row in range(table.shape[0]):
    for col in range(table.shape[1]):
      # Change (toggle) the value on the mirror
      #print(f'row: {row}, col{col}')
      table[row,col] = '#' if table[row,col]=='.' else '.'

      hscores = find_and_verify_horiz(table)
      for h in hscores:
        if h>=0 and 100*(h+1) != oldCount:
          score_changes.append(100*(h+1))

      vscores = find_and_verify_vert(table)
      for v in vscores:
        if v>=0 and (v+1) != oldCount:
          score_changes.append(v+1)

      # Toggle the changed character back the value on the mirror
      table[row,col] = '#' if table[row,col]=='.' else '.'

  print(score_changes)
  if (score_changes):
    return max(score_changes)
  else:
    return (-1)

count[10]

find_and_verify_vert(table)

for cnt in range(table.shape[0]):
  print(''.join(table[cnt,:]))

row = 6
col = 1
table[row,col] = '#' if table[row,col]=='.' else '.'

## Part 1     Find the axis a matrix is mirrored around
#with open('Dec13test.txt','r') as f:
#with open('Dec13test4.txt','r') as f:
with open('Dec13.txt','r') as f:
  lines = f.readlines()

count = []
sum = 0
inList = []
puzCnt = 0
# Need extra \n at end for this to process the last table
# Take care !!!!!!!!!
for line in lines:
  if (line.strip()):
    inList.append(list(line.strip()))
  else:
    print(line)
    if len(inList)==0:
      break

    puzCnt +=1
    table = np.array(inList)
    inList = []

    vscore = max(find_and_verify_vert(table))
    if (vscore>=0):
      count.append(vscore+1)
      sum += vscore+1

    hscore = max(find_and_verify_horiz(table))
    if (hscore>=0):
      count.append(100*(hscore+1))
      sum += 100*(hscore+1)

    if vscore<0 and hscore<0:
      count.append(0)
      print(f'No symmetry puzzle {puzCnt}')

    if hscore>0 and vscore>0:
      print(f'Both symmetries Puzzle {puzCnt}')

    print(f'Puzzle: {puzCnt} h:{hscore} v:{vscore}')
    #print(table)

sum

###  PART 2
# If one of the squares changes, the symmetry will change
# Try a brute force, searching though each point of very map and complementing it and
# testing for a change in symmetry.
# Calculate a new sum ->

# Need to read the tables from the file again
new_count = []                  #### Use count from oldlist to find change
new_sum = 0
inList = []
puzCnt = 0
# Need extra \n at end for this to process the last table
# Take care !!!!!!!!!
for line in lines:
  if (line.strip()):
    inList.append(list(line.strip()))
  else:
    print(line)
    if len(inList)==0:
      break

    puzCnt +=1
    table = np.array(inList)
    inList = []

    new_score = test_change_one(table,count[puzCnt-1])

    if new_score < 0:
      new_sum+=0
      print(f'puzzle {puzCnt} score did not change')
    else:
      new_sum += new_score
      new_count.append(new_score)

    print(f'Puzzle: {puzCnt} new:{new_score} old:{count[puzCnt-1]}')
    #print(table)

new_sum

# Commented out IPython magic to ensure Python compatibility.
# %debug

print(f'Puzzle: {puzCnt} new:{new_score} old:{count[puzCnt-1]}')

for cnt in range(table.shape[0]):
  print(''.join(table[cnt,:]))

row = 1
col = 6
puzCnt

offset = 2
np.all(np.char.equal(table[:,vert-offset], table[:,vert+offset+1]))

np.char.equal(table[:,2], table[:,7])

table[:,[2,7]]

# Function to return the value encoded in a string
def decode_string(inStr):
  if int(inStr,2):
    return np.char.str_len(np.array(inStr.replace('0',' ').strip().split()))
  else:
    return np.array([0])

# Test if the inStr values match the vals desired
def test_string(inStr,val):
  inVals = decode_string(inStr)
  #print(inVals)
  if np.all(inVals.shape == val.shape) and np.all(inVals==vals):
    return 1
  else:
    return 0

correctList

np.sum(np.char.equal(cnt_str_array,'1'))

536870912 - 32000000

line = '1'
if line:
  print('T')
else:
  print('F')

