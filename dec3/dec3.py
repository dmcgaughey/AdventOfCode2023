# -*- coding: utf-8 -*-
"""Dec3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UcJESa44u14Z6E6am_uWXvweZw8rJymi
"""

import numpy as np

with open('Dec3.txt','r') as f:
  lines = f.readlines()

import re

total=0
for row in range(len(lines)):
  col = 0
  templine = lines[row]
  while col<len(templine):
    if not templine[col].isnumeric():
      col += 1
    else:
      # Find length of number
      numstart = col
      numend = col + 1
      while templine[numend].isnumeric():
        numend += 1
      col = numend

      # Find surrounding box
      colstart = numstart-1 if numstart>0 else numstart
      colend = numend+1 if numend+1<len(templine) else numend
      rowstart = row-1 if row>0 else row
      rowend = row +1 if row+1<len(lines) else row

      # Test for any symbol in the surrounding box
      regex = re.compile('[@_!#$%&*?/\|~:+=-]')

      hassymbol=False
      for cnt in range(rowstart,rowend+1):
        #print((lines[cnt][colstart:colend]))
        if(regex.search(lines[cnt][colstart:colend]) != None):  hassymbol=True

        # If there was an adjacent symbol, extract the integer value and add it to the running sum
      if hassymbol:
        #print(f'Row:[{rowstart},{rowend}] Col:[{colstart},{colend}] ')
        val = int(templine[numstart:numend])
        #print(val)
        total += val

print(f'Total is {total}')

# Function to scan an integer -> can use scan both directions for all 3 cases
#  scan_right, or scan_left or scan_both
def scan_both(text, col):
  start = col
  finish = col+1
  while start>0 and text[start-1].isnumeric():
    start -= 1
  while finish<len(text) and text[finish].isnumeric():
    finish += 1
  #print(text[start:finish])
  return(int(text[start:finish]))

total=0
for row in range(len(lines)):
  for col in range(len(lines[row])):
    if lines[row][col] == '*':
      # Found a star -> now need to find locations of the two numbers
      # Find surrounding box
      #  ---
      #  -*-
      #  ---

      detectionMatrix = np.zeros([3,3])

      # Test for numerical values in any of the 9 adjacent squares
      for r2 in range(-1,2):
        for c2 in range(-1,2):
          if (r2+row)<0 : continue
          if (r2+row)>=len(lines): continue
          if (c2+col)<0: continue
          if (c2+col)>=len(lines[row]): continue

          detectionMatrix[r2+1,c2+1] = lines[r2+row][c2+col].isnumeric()

      # If if you sum each row and there are at least 2 non-zero rows, then you have adjacent
      # gears
      nz_rows = np.sum(detectionMatrix,axis=1)>0
      nz_cols = np.sum(detectionMatrix,axis=0)>0
      if np.sum(nz_rows) == 2: num_gears=2
      elif (nz_cols[1] == False) and (np.sum(detectionMatrix)>1): num_gears =2
      else:
        num_gears = 1
        continue

      #print(detectionMatrix)
      #print(nz_rows)
      #print(num_gears)


      # If there are two rows, just extract a number from each row.
      # In a gven row, determine if one or two words for direction to search
      # and detection pattern

      # For a row with 1 adjacent number there are 6 combinations
      # xx100, 010, 001xx, x110, 011x, x111x
      # For a row with 2 adjacent is 1 combination
      # xx101xx

      # Now you know there are two gears adjacent
      # Now scan and extract the adjacent integers

      vals = []
      if np.sum(nz_rows) == 2:
        # Gears in two seperate rows
        # Find which two rows and then scan each row
        for cnt in range(-1,2):
          if nz_rows[cnt+1]:
            if detectionMatrix[cnt+1][0]:
              vals.append( scan_both(lines[row+cnt],col-1) )
            elif detectionMatrix[cnt+1][2]:
              vals.append( scan_both(lines[row+cnt],col+1) )
            else:
              vals.append( int(lines[row+cnt][col]) )
      else:
        # Both values are in a single row -> so find row and scan from edges
        for cnt in range(-1,2):
          if nz_rows[cnt+1]:
            vals.append( scan_both(lines[row+cnt],col-1) )
            vals.append( scan_both(lines[row+cnt],col+1) )

      total += vals[0]*vals[1]

print(f'Total is {total}')

# nz_cols

